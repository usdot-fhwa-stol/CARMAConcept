/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Simulink Coder, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Simulink Coder User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Fri Aug 21 11:00:19 2015
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif
#include "EncodeBSM_bus.h"

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <math.h>
#include "bsm.h"
#include "der_encoder.h"
#include "bsm_encoder.h"
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 1
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
/* extern double func(double a); */

uint16_T encodeElev(real32_T);

uint32_T encodeAccuracy(BasicSafetyMessage*);

uint16_T encodeSpeedAndTransmission(BasicSafetyMessage*);

void encodeAccelSet(BasicSafetyMessage*, uint8_T*);

uint16_T encodeBrakes(BasicSafetyMessage*);

void encodeSize(BasicSafetyMessage*, uint8_T*);

/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/*
 * Output functions
 *
 */
void EncodeBSM_Outputs_wrapper(const BasicSafetyMessage *BSM_Data,
                          uint8_T *Buffer,
                          uint32_T *Length)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
	BSM rawMsg;
	EncodedBSM enc;
	// Convert BasicSafetyMessage to more raw BSM struct

	// Store BSMblob data
	rawMsg.msgCnt = BSM_Data->msgCnt;
	rawMsg.msgID = BSM_Data->msgID;
	rawMsg.id = BSM_Data->id;
	rawMsg.secMark = BSM_Data->secMark_ms;
	rawMsg.lat = BSM_Data->lat_deg * 10000000;
	rawMsg.lon = BSM_Data->lon_deg * 10000000;
	rawMsg.elev = encodeElev(BSM_Data->elev_m);
	rawMsg.accuracy = encodeAccuracy(BSM_Data);
	rawMsg.speed = encodeSpeedAndTransmission(BSM_Data);
	rawMsg.heading = (uint16_T) (BSM_Data->heading_deg / 0.0125);
	rawMsg.angle = (uint8_T) (BSM_Data->angle_deg / 1.5);
	encodeAccelSet(BSM_Data, rawMsg.accelSet);
	rawMsg.brakes = encodeBrakes(BSM_Data);
	encodeSize(BSM_Data, rawMsg.size);

	// Store CaccData extension data
	rawMsg.flags = BSM_Data->caccFlags_bitmask;
	rawMsg.setSpeed = (uint16_T) (BSM_Data->setSpeed_m_s / 0.02);
	rawMsg.throtPos = (uint8_T) (BSM_Data->throtPos_percent / 0.5);
	rawMsg.lclPN = BSM_Data->lclPN_mm;
	rawMsg.lclPE = BSM_Data->lclPE_mm;
	rawMsg.lclPD = BSM_Data->lclPD_mm;
	rawMsg.roll = (int16_T) (BSM_Data->roll_deg * 32768.0);
	rawMsg.pitch = (int16_T) (BSM_Data->pitch_deg * 32768.0);
	rawMsg.yaw = (int16_T) (BSM_Data->pitch_deg * 32768.0);
	rawMsg.hPosAcry = BSM_Data->hPosAcry_m;
	rawMsg.vPosAcry = BSM_Data->vPosAcry_m;
	rawMsg.fwrdVel = BSM_Data->frwdVel_m_s;
	rawMsg.rightVel = BSM_Data->rightVel_m_s;
	rawMsg.downVel = BSM_Data->downVel_m_s;
	rawMsg.velAcc = BSM_Data->velAcc_m_s;
	rawMsg.fwrdAcc = BSM_Data->frwdAcc_mm_s_s;
	rawMsg.rightAcc = BSM_Data->rightAcc_mm_s_s;
	rawMsg.dwnAcc = BSM_Data->dwnAcc_mm_s_s;
	
	rawMsg.grpID = BSM_Data->grpID;
	rawMsg.grpSize = BSM_Data->grpSize;
	rawMsg.grpMode = BSM_Data->grpMode;
	rawMsg.grpManDes = BSM_Data->grpManDes;
	rawMsg.grpManID = BSM_Data->grpManID;
	rawMsg.vehID = BSM_Data->vehID;
	rawMsg.frntCutIn = BSM_Data->frntCutIn;
	rawMsg.vehGrpPos = BSM_Data->vehGrpPos;
	rawMsg.vehFltMode = BSM_Data->vehFltMode;
	rawMsg.vehManDes = BSM_Data->vehManDes;
	rawMsg.vehManID = BSM_Data->vehManID;
	rawMsg.distToPVeh = BSM_Data->distToPVeh_m;
	rawMsg.relSpdPVeh = (uint8_T) ((BSM_Data->relSpdPVeh_m_s/0.625) + 64);
	rawMsg.distToLVeh = BSM_Data->distToLVeh_m;
	rawMsg.relSpdLVeh = (uint8_T) ((BSM_Data->relSpdLVeh_m_s/0.625) + 64);
	rawMsg.desTGapPVeh = BSM_Data->desTGapPVeh_s * 10;
	rawMsg.desTGapLVeh = BSM_Data->desTGapLVeh_s * 10;
	rawMsg.estDisPVeh = BSM_Data->estDisPVeh_m;
	rawMsg.estDisLVeh = BSM_Data->estDisLVeh_m;
	rawMsg.desSpd = BSM_Data->desSpeed_m_s;
	rawMsg.desTrq = BSM_Data->desTrq_N_m;

	rawMsg.userDE1 = BSM_Data->userDE1;
	rawMsg.userDE2 = BSM_Data->userDE2;
	rawMsg.userDE3 = BSM_Data->userDE3;
	rawMsg.userDE4 = BSM_Data->userDE4;
	rawMsg.userDE5 = BSM_Data->userDE5;
	
	// Convert BSM to binary array, then return via memcpy
	enc = encodeBSM(rawMsg);
	memset(Buffer, 0, 1472);
	memcpy(Buffer, enc.buf, enc.length);
	*Length = enc.length;
}

uint16_T encodeElev(real32_T elev_m) {
	uint16_T out = 0;
	
	if (elev_m >= 0) {
		// Above the reference ellipsoid
		out = (uint16_T) (elev_m * 10);
	} else if (elev_m >= -409.5 && elev_m <= - 0.1) {
		out = (uint16_T) (((elev_m + 409.5) / 0.1) + 0xF001);
	} else {
		out = 0xF000;
	}

	return out;
}

uint32_T encodeAccuracy(BasicSafetyMessage* bsm) {
	uint32_T out = 0;

	out |= ((uint8_T)(bsm->semi_major_accuracy_m / 0.05)) << 24;
	out |= ((uint8_T)(bsm->semi_minor_accuracy_m / 0.05)) << 16;
	out |= ((uint16_T)(bsm->semi_major_accuracy_orientation_deg / 0.0054932479));

	return out;
}

uint16_T encodeSpeedAndTransmission(BasicSafetyMessage* bsm) {
	uint16_T out = 0;

	out |= bsm->transmission_enum << 14;
	out |= ((uint16_T) (bsm->speed_m_s / 0.02) & 0x3FFF); // Bitmask to ensure value range validity

	return out;
}

void encodeAccelSet(BasicSafetyMessage* bsm, uint8_T* accelSet) {
	int16_T lonAcc = 0;
	int16_T latAcc = 0;
	int8_T vertAcc = 0;
	int16_T yawRate = 0;

	lonAcc = bsm->long_acceleration_m_s_s / 0.01;
	latAcc = bsm->lat_acceleration_m_s_s / 0.01;
	vertAcc = (bsm->vertical_acceleration_g + 50) / 0.02;
	yawRate = bsm->vertical_acceleration_g  / 0.01;

	memcpy(accelSet, (void *) &lonAcc, 2);
	memcpy(accelSet + 2, (void *) &latAcc, 2);
	memcpy(accelSet + 4, (void *) &vertAcc, 1);
	memcpy(accelSet + 5, (void *) &yawRate, 2);
}

uint16_T encodeBrakes(BasicSafetyMessage* bsm) {
	uint16_T out = 0;

	out |= ((bsm->wheelBrakes_bitmask & 0xF) << 12);
	out |= ((bsm->wheelBrakesUnavailable & 0x1) << 11);
	out |= ((bsm->tractionControlState_enum & 0x3) << 8);
	out |= ((bsm->anti_lock_brake_status_enum & 0x3) << 6);
	out |= ((bsm->stability_control_status_enum & 0x3) << 4);
	out |= ((bsm->brake_boost_enum & 0x3) << 2);
	out |= (bsm->auxiliary_brakes_status_enum & 0x3);
	
	return out;
}

void encodeSize(BasicSafetyMessage* bsm, uint8_T* size) {
	uint16_T length = 0;
	size[0] = (uint8_T) (bsm->vehicle_width_cm);

	length = (uint16_T) (bsm->vehicle_height_cm);
	memcpy(&size[1], (uint8_T *) (&length), 2);
}

/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */

